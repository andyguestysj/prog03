---
title: C Memory
permalink: /docs/c2-01/
---

Lets take a look at how C works with memory.  

## C Memory Structure

<centre><img src="/assets/img/topic3/cmem1.png" alt="C Memory structure"></centre>

Memory is C is segmented in a similar way to memory in Java, there are areas for code, static data, the stack and the heap.  
 

### Text Segment
<div class="row">
    <div class="col-md-8">
<ul>
<li>The Text segment contains machine code of the compiled program. </li>
<li>Usually, the text segment is sharable so that only a single copy needs to be in memory for frequently executed programs, such as text editors, the C compiler, the shells, and so on. </li>
<li>The text segment of an executable object file is often read-only segment that prevents a program from being accidentally modified.
</li>
</ul>
    </div>
    <div class="col-md-4">
<img src="/assets/img/topic3/cmem2.png" alt="C Memory">
    </div>
</div>

### Initialized Data Segment
<div class="row">
    <div class="col-md-8">
<ul>
<li>Initialized data stores all global, static, constant, and external variables ( declared with extern keyword ) that are initialized beforehand.  </li>
<li>Data segment is not read-only, since the values of the variables can be altered at run time.</li>
<li>This segment can be further classified into initialized read-only area and initialized read-write area.
Read-only uses <b>const</b></li>
</ul>
    </div>
    <div class="col-md-4">
<img src="/assets/img/topic3/cmem2.png" alt="C Memory">
    </div>
</div>

```c
char c[]="Some text";             /* global variable stored in Initialized Data Segment in read/write area */
const char d[]="Some more text";  /* global variable stored in Initialized Data Segment in read-only area */

int main()
{
  static int i=11;                /* static variable stored in Initialized Data Segment */
  return 0;
}
```

### Uninitialized Data Segment (bss)
<div class="row">
    <div class="col-md-8">
<ul>
<li>Data in this segment is initialized to arithmetic 0 before the program starts executing.  </li>
<li>Uninitialized data starts at the end of the data segment and contains all global variables and static variables that are initialized to 0 or do not have explicit initialization in source code</li>
</ul>
    </div>
    <div class="col-md-4">
<img src="/assets/img/topic3/cmem2.png" alt="C Memory">
    </div>
</div>

```c
char c[]="Some text";             /* global variable stored in Initialized Data Segment in read/write area */
const char d[]="Some more text";  /* global variable stored in Initialized Data Segment in read-only area */
<b>char e;                        /* Uninitialised variable stored in bss*/</b>

int main()
{
  static int i=11;                /* static variable stored in Initialized Data Segment
  <b>static int j;                /* Uninitialised variable stored in bss*/</b>
  return 0;
}
```

### The Heap
<div class="row">
    <div class="col-md-8">
<ul>
<li>The Heap is the segment where dynamic memory allocation usually takes place. </li>
<li>When some more memory need to be allocated using malloc* and calloc* function, heap grows upward. </li>
<li>The Heap area is shared by all shared libraries and dynamically loaded modules in a process.</li>
</ul>
    </div>
    <div class="col-md-4">
<img src="/assets/img/topic3/cmem2.png" alt="C Memory">
    </div>
</div>

```c
#include <stdlib.h>
int main()
{
  char *p=(char*)malloc(sizeof(char));                /* memory allocation in the heap
  return 0;
}
```
\* we'll come on to the meaning of *malloc* and *calloc* soon

### The Stack
<div class="row">
    <div class="col-md-8">
<ul>
<li>Stack segment is used to store all local variables and is used for passing arguments to the functions along with the return address of the instruction which is to be executed after the function call is over. </li>
<li>Local variables have a scope to the block which they are defined in, they are created when control enters into the block. </li>
<li>All recursive function calls are added to stack.</li>
<li></li>
<li>The stack and heap are traditionally located at opposite ends of the process's virtual address space.</li>
<li>The stack grows downward, starting at a high memory address</li>
<li>But individual variables are still stored upwards!</li>
</ul>
    </div>
    <div class="col-md-4">
<img src="/assets/img/topic3/cmem2.png" alt="C Memory">
    </div>
</div>

#### Frame Structure
<div class="row">
    <div class="col-md-6">
<ul>
<li>A <i>frame</I> fills <b>down</b> from a starting memory location</li>
<li>Added to the frame, in order, are</li>
<li><ul>
<li>Return Address - the address the function was called from</li>
<li>Parameters - the variables passed to the function</li>
<li>Local Variables</li>
</ul></li>
</ul>
    </div>
    <div class="col-md-6">
<img src="/assets/img/topic3/framestruct2.png" alt="C Memory- Frame structure">
    </div>
</div>

While the frame is filled downwards from a high memory address individual variables fill upwards.  

```c
#include <stdio.h>
#include <stdalign.h>

int main(void) {

int integer1=1;
int integer2=2;
int integer3=3;

printf("integer1 = %d Memory address %p\n",integer1,&integer1);
printf("integer2 = %d Memory address %p\n",integer2,&integer2);
printf("integer3 = %d Memory address %p\n",integer3,&integer3);


return 0;
}
```

```console
integer1 = 1 Memory address 0x7ffe196e4ad8
integer2 = 2 Memory address 0x7ffe196e4ad4
integer3 = 3 Memory address 0x7ffe196e4ad0
```
An integer takes up 4 bytes in memory. In the example above integer1 is stored "at" address 0x7ffe196e4ad8, but it takes up four bytes of memory and the address 0x7ffe196e4ad8 only stores 1 byte. Where are the other three bytes stored? They are stored in the next three memory addresses going *upwards*. integer1 is stored in addresses 0x7ffe196e4ad8, 0x7ffe196e4ad9, 0x7ffe196e4ada and 0x7ffe196e4adb. (The addresses are in hexadecimal format - base 16).  

When a variable is added to the stack the size of the variable is subtracted from the last used address to determine the first memory location the variable will be stored in and that gap gets filled up with the variable.  

So before integer1 is created the last used address is 0x7ffe196e4adc. We want to create an integer. An integer takes up 4 bytes so we subtract 4 from the address to get 0x7ffe196e4ad8. So integer1 is stored in four bytes starting at 0x7ffe196e4ad8 and using the next three bytes up from there.  

Its a little more complex than that. Computers have a memory alignment. This alignment is based on the processor. For a 64bit machine the alignment is 8 bytes. Memory is aligned in 8 byte sections that can be loaded in to the processor faster.  

An 8 byte *double* can be stored in any contiguous 8 bytes of memory but for speed of access it is better if it is aligned to the 8 byte memory alignment.  

In the example below the aligned variable will be read in to the processor in a single read from memory but the unaligned variable will require two reads.  
<centre><img src="/assets/img/topic3/aligned.png" alt="C Memory- Frame structure"></centre>
<centre><img src="/assets/img/topic3/unaligned.png" alt="C Memory- Frame structure"></centre>

When variables are added to the stack they are added so that they are not split across the alignment boundaries.

The machine used by repl.it appears to have 4 byte boundaries.  

```c
#include <stdio.h>
#include <stdalign.h>

int main(void) {

int integer1=1;
short short2=2;
int integer3=3;

printf("integer1 =%d Memory address%p\n",integer1,&integer1);
printf("short2 =%d Memory address%p\n",short2,&short2);
printf("integer3 =%d Memory address%p\n",integer3,&integer3);


return 0;
}
```

```console
integer1 =1 Memory address0x7ffe5d4f6428
short2 =2 Memory address0x7ffe5d4f6426
integer3 =3 Memory address0x7ffe5d4f6420
```

A **short** only takes up two bytes of space, as can be seen above. After that we create another 4 byte integer. Looking at the above we can see its starting address is 6 bytes below the short, why 6 rather than 4?  

|M+3|M+2|M+1|M+0|
|---|---|---|---|
|i1+3|i1+2|i1+1|i1+0|
|s2+1|s2+0|||
|i3+3|i3+2|i3+1|i3+0|

Including the extra 2 bytes to offset the location of the second integer keeps it aligned. Without it the variable would take longer to read from memory.  

|M+3|M+2|M+1|M+0|
|---|---|---|---|
|i1+3|i1+2|i1+1|i1+0|
|s2+1|s2+0|i3+3|i3+2|
|i3+1|i3+0|||

## C Variables

C variables have a fixed size in memory.  

|Type|Stores|Size|
|---|---|---|
|int|integer number|4-bytes|
|short|integer number|2-bytes|
|long|integer number|8-bytes|
|char|character|1-byte|
|float|floating point number|4-bytes|
|double|floating point number|8-bytes|
|void *|pointers|8-bytes on (64 bit machines)|

## Arrays

Arrays are created as follows.  
```c 
int iNumArray[3];
int iNum[5] = {1,5,2,4,3};
int Numbers[] = {3,6,2,8,7};
```
You can specify the size of the array explicitly or leave it blank and let the compiler define so it is big enough to store the initial data. The initial declaration must determine the size one way or another though.  
```c
int anArray[];
```
is not valid.  

Values in the array can be read or altered using an *index* value;
```c
int Numbers[] = {3,6,2,8,7};
printf("%d\n", Numbers[2]);
Numbers[3] = 1;
```

Note that C will let you access *indexes* that are outwith the bounds of the array.

```c
int Numbers[] = {3,6,2,8,7};

Numbers[10] = 1;
Numbers[-2] = 1;
```
The compiler will *warn* you that the index is out of bounds but it will not stop you doing this. Doing this may cause your code to crash or may work. If it works its results may be unpredictable. For example the following code (available at [https://repl.it/@andyguest/cArrays](https://repl.it/@andyguest/cArrays))  

```c
#include <stdio.h>

int main(void) {

int a[] = {1,1,1};
int Numbers[] = {3,6,2,8,7};
int b[] = {2,2,2};


for (int i=-5;i<10;i++)
{
  printf("[%d] [%d]\n",i,Numbers[i]);
}

return 0;
}
```
produces the following output  
```console
[-5] [0]
[-4] [-4]
[-3] [2]
[-2] [2]
[-1] [2]
[0] [3]
[1] [6]
[2] [2]
[3] [8]
[4] [7]
[5] [0]
[6] [4195328]
[7] [0]
[8] [1]
[9] [1]

```
Why does this happen? Well two things are coming in to play here - how an array is stored in memory and how variables declared next to each other are stored in memory.  

### Arrays In Memory

An array is stored in sequential, contiguous spaces in memory. Each item in an array takes up a number of bytes based on its type and the next item in the array is stored immeadiately after the previous one.  
<centre>        
    <img src="{{ "/assets/img/arrays.jpg" | relative_url }}" alt="Array memory structure" class="img-responsive">
</centre>

### Variables In Memory
When we declared variables one after another they are stored in memory consecutively, or at least kind of consecutively. Every variable type has an *alignment requirement*. This *alignment requirement* is the minimum space, in bytes, that must occur between variables of the same type.  

The alignment requirement of an array of integers is 4 bytes.  

So taking these two things together and looking at the above example  
```c
int a[] = {1,1,1};
int Numbers[] = {3,6,2,8,7};
int b[] = {2,2,2};
```
we have three arrays of integers. These are added in to memory with a gap of four bytes between them.