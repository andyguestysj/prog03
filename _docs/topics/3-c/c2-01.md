---
title: C Memory
permalink: /docs/c2-01/
---

Lets take a look at how C works with memory.  

## C Memory Structure

<centre><img src="/assets/img/topic3/cmem1.png" alt="C Memory structure"></centre>

Memory is C is segmented in a similar way to memory in Java, there are areas for code, static data, the stack and the heap.  
 

### Text Segment
<div class="row">
    <div class="col-md-8">
<ul>
<li>The Text segment contains machine code of the compiled program. </li>
<li>Usually, the text segment is sharable so that only a single copy needs to be in memory for frequently executed programs, such as text editors, the C compiler, the shells, and so on. </li>
<li>The text segment of an executable object file is often read-only segment that prevents a program from being accidentally modified.
</li>
</ul>
    </div>
    <div class="col-md-4">
<img src="/assets/img/topic3/cmem2.png" alt="C Memory">
    </div>
</div>

### Initialized Data Segment
<div class="row">
    <div class="col-md-8">
<ul>
<li>Initialized data stores all global, static, constant, and external variables ( declared with extern keyword ) that are initialized beforehand.  </li>
<li>Data segment is not read-only, since the values of the variables can be altered at run time.</li>
<li>This segment can be further classified into initialized read-only area and initialized read-write area.
Read-only uses <b>const</b></li>
</ul>
    </div>
    <div class="col-md-4">
<img src="/assets/img/topic3/cmem2.png" alt="C Memory">
    </div>
</div>

```c
char c[]="Some text";             /* global variable stored in Initialized Data Segment in read/write area */
const char d[]="Some more text";  /* global variable stored in Initialized Data Segment in read-only area */

int main()
{
  static int i=11;                /* static variable stored in Initialized Data Segment */
  return 0;
}
```

### Uninitialized Data Segment (bss)
<div class="row">
    <div class="col-md-8">
<ul>
<li>Data in this segment is initialized to arithmetic 0 before the program starts executing.  </li>
<li>Uninitialized data starts at the end of the data segment and contains all global variables and static variables that are initialized to 0 or do not have explicit initialization in source code</li>
</ul>
    </div>
    <div class="col-md-4">
<img src="/assets/img/topic3/cmem2.png" alt="C Memory">
    </div>
</div>

```c
char c[]="Some text";             /* global variable stored in Initialized Data Segment in read/write area */
const char d[]="Some more text";  /* global variable stored in Initialized Data Segment in read-only area */
<b>char e;                          /* Uninitialised variable stored in bss*/</b>

int main()
{
  static int i=11;                /* static variable stored in Initialized Data Segment
  <b>static int j;                  /* Uninitialised variable stored in bss*/</b>
  return 0;
}
```

## C Variables

C variables have a fixed size in memory.  

|Type|Stores|Size|
|---|---|---|
|int|integer number|4-bytes|
|short|integer number|2-bytes|
|long|integer number|8-bytes|
|char|character|1-byte|
|float|floating point number|4-bytes|
|double|floating point number|8-bytes|
|void *|pointers|8-bytes on (64 bit machines)|

The size used to store each type is significant.  

## 










## Arrays

Arrays are created as follows.  
```c 
int iNumArray[3];
int iNum[5] = {1,5,2,4,3};
int Numbers[] = {3,6,2,8,7};
```
You can specify the size of the array explicitly or leave it blank and let the compiler define so it is big enough to store the initial data. The initial declaration must determine the size one way or another though.  
```c
int anArray[];
```
is not valid.  

Values in the array can be read or altered using an *index* value;
```c
int Numbers[] = {3,6,2,8,7};
printf("%d\n", Numbers[2]);
Numbers[3] = 1;
```

Note that C will let you access *indexes* that are outwith the bounds of the array.

```c
int Numbers[] = {3,6,2,8,7};

Numbers[10] = 1;
Numbers[-2] = 1;
```
The compiler will *warn* you that the index is out of bounds but it will not stop you doing this. Doing this may cause your code to crash or may work. If it works its results may be unpredictable. For example the following code (available at [https://repl.it/@andyguest/cArrays](https://repl.it/@andyguest/cArrays))  

```c
#include <stdio.h>

int main(void) {

int a[] = {1,1,1};
int Numbers[] = {3,6,2,8,7};
int b[] = {2,2,2};


for (int i=-5;i<10;i++)
{
  printf("[%d] [%d]\n",i,Numbers[i]);
}

return 0;
}
```
produces the following output  
```console
[-5] [0]
[-4] [-4]
[-3] [2]
[-2] [2]
[-1] [2]
[0] [3]
[1] [6]
[2] [2]
[3] [8]
[4] [7]
[5] [0]
[6] [4195328]
[7] [0]
[8] [1]
[9] [1]

```
Why does this happen? Well two things are coming in to play here - how an array is stored in memory and how variables declared next to each other are stored in memory.  

### Arrays In Memory

An array is stored in sequential, contiguous spaces in memory. Each item in an array takes up a number of bytes based on its type and the next item in the array is stored immeadiately after the previous one.  
<centre>        
    <img src="{{ "/assets/img/arrays.jpg" | relative_url }}" alt="Array memory structure" class="img-responsive">
</centre>

### Variables In Memory
When we declared variables one after another they are stored in memory consecutively, or at least kind of consecutively. Every variable type has an *alignment requirement*. This *alignment requirement* is the minimum space, in bytes, that must occur between variables of the same type.  

The alignment requirement of an array of integers is 4 bytes.  

So taking these two things together and looking at the above example  
```c
int a[] = {1,1,1};
int Numbers[] = {3,6,2,8,7};
int b[] = {2,2,2};
```
we have three arrays of integers. These are added in to memory with a gap of four bytes between them.